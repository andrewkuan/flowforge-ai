import { db, ChatSession, ChatMessage } from './database'

// Hook-like functions for database operations
export class StorageService {
  // Session operations
  static async createNewSession(firstMessage?: string): Promise<number> {
    const title = firstMessage ? db.generateSessionTitle(firstMessage) : 'New Workflow'
    return await db.createSession(title)
  }

  static async getCurrentSession(): Promise<ChatSession | null> {
    const session = await db.getActiveSession()
    return session ?? null
  }

  static async loadSession(sessionId: number): Promise<ChatMessage[]> {
    await db.setActiveSession(sessionId)
    return await db.getSessionMessages(sessionId)
  }

  static async getAllSessions(): Promise<ChatSession[]> {
    return await db.getAllSessions()
  }

  // Message operations
  static async saveMessage(
    sessionId: number, 
    role: 'user' | 'assistant', 
    content: string
  ): Promise<void> {
    await db.addMessage(sessionId, role, content)
  }

  static async getSessionMessages(sessionId: number): Promise<ChatMessage[]> {
    return await db.getSessionMessages(sessionId)
  }

  // Workflow operations
  static async saveWorkflow(
    sessionId: number,
    jsonContent: string,
    workflowType?: 'deterministic' | 'ai-enhanced' | 'agentic'
  ): Promise<void> {
    // Extract workflow name from JSON if possible
    let name = 'Generated Workflow'
    let description = 'n8n workflow generated by FlowForge AI'
    
    try {
      const workflow = JSON.parse(jsonContent)
      if (workflow.name) {
        name = workflow.name
      }
      if (workflow.nodes && workflow.nodes.length > 0) {
        const nodeTypes = workflow.nodes.map((node: any) => 
          node.type?.split('.').pop() || 'node'
        ).join(', ')
        description = `Workflow with ${workflow.nodes.length} nodes: ${nodeTypes}`
      }
    } catch (e) {
      // Use defaults if JSON parsing fails
    }

    await db.saveWorkflow(sessionId, name, description, jsonContent, workflowType)
  }

  // Session management
  static async startNewSession(): Promise<number> {
    return await this.createNewSession()
  }

  static async deleteSession(sessionId: number): Promise<void> {
    await db.deleteSession(sessionId)
  }

  static async clearAllData(): Promise<void> {
    await db.clearAllData()
  }

  // Auto-save functionality
  static async autoSaveMessage(
    role: 'user' | 'assistant',
    content: string
  ): Promise<void> {
    try {
      let session = await this.getCurrentSession()
      
      if (!session) {
        // Create new session if none exists
        const sessionId = await this.createNewSession(
          role === 'user' ? content : undefined
        )
        session = await db.getActiveSession() ?? null
      }

      if (session?.id) {
        await this.saveMessage(session.id, role, content)
        
        // Update session title if this is the first user message
        if (role === 'user') {
          const messages = await this.getSessionMessages(session.id)
          const userMessages = messages.filter(m => m.role === 'user')
          
          if (userMessages.length === 1) {
            // This is the first user message, update title
            const title = db.generateSessionTitle(content)
            await db.updateSessionTitle(session.id, title)
          }
        }
      }
    } catch (error) {
      console.error('Error auto-saving message:', error)
      // Don't throw - let the app continue working even if storage fails
    }
  }

  // Initialize or resume session
  static async initializeSession(): Promise<{
    sessionId: number | null
    messages: ChatMessage[]
  }> {
    try {
      const currentSession = await this.getCurrentSession()
      
      if (currentSession?.id) {
        const messages = await this.getSessionMessages(currentSession.id)
        return {
          sessionId: currentSession.id,
          messages
        }
      }
      
      return {
        sessionId: null,
        messages: []
      }
    } catch (error) {
      console.error('Error initializing session:', error)
      return {
        sessionId: null,
        messages: []
      }
    }
  }
}